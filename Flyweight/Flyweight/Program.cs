/* Инфо

    * Паттерн Приспособленец (Flyweight) - структурный шаблон проектирования, который позволяет 
      использовать разделяемые объекты сразу в нескольких контекстах. Данный паттерн используется 
      преимущественно для оптимизации работы с памятью.

    * В качестве стандартного применения данного паттерна можно привести следующий пример. 
      Текст состоит из отдельных символов. Каждый символ может встречаться на одной странице 
      текста много раз. Однако в компьютерной программе было бы слишком накладно выделять 
      память для каждого отдельного символа в тексте. Гораздо проще было бы определить полный 
      набор символов, например, в виде таблицы из 128 знаков (алфавитно-цифровые символы 
      в разных регистрах, знаки препинания и т.д.). А в тексте применить этот набор общих 
      разделяемых символов, вместо сотен и тысяч объектов, которые могли бы использоваться 
      в тексте. И как следствие подобного подхода будет уменьшение количества используемых 
      объектов и уменьшение используемой памяти.

    * Паттерн Приспособленец следует применять при соблюдении всех следующих условий:

        * Когда приложение использует большое количество однообразных объектов, из-за чего 
          происходит выделение большого количества памяти

        * Когда часть состояния объекта, которое является изменяемым, можно вынести во вне. 
          Вынесение внешнего состояния позволяет заменить множество объектов небольшой 
          группой общих разделяемых объектов.

        * Ключевым моментом здесь является разделение состояния на внутренне и внешнее. 
          Внутреннее состояние не зависит от контекста. В примере с символами внутреннее 
          состояние описывается кодом символа из таблицы кодировки. Так как внутреннее 
          состояние не зависит от контекста, то оно может быть разделяемым и поэтому 
          выносится в разделяемые объекты.

        * Внешнее состояние зависит от контекста, является изменчивым. В применении 
          к символам внешнее состояние может представлять положение символа на странице. 
          То есть код символа может быть использован многими символами, тогда как положение 
          на странице будет для каждого символа индивидуально.

        * При создании приспособленца внешнее состояние выносится. В приспособленце остается 
          только внутреннее состояние. То есть в примере с символами приспособленец будет хранить 
          код символа.

    * Рассмотрим пример. Допустим, мы проектируем программу для моделирования города. Город состоит 
      из отдельных домов, поэтому нам надо создать объекты этих домов. Однако домов в городе может 
      быть множество: сотни, тысячи. Они могут иметь разный вид, отличаться по различным признакам. 
      Однако, как правило, многие дома делаются по стандартным проектам. И фактически мы можем выделить 
      несколько типов домов, например, пятиэтажные кирпичные хрущевки, многоэтажные панельные высотки 
      и так далее.

    * Используя некоторый анализ, мы можем выделить внутренне состояния домов и внешнее. К внутреннему 
      состоянию, например, может относиться количество этажей, материал (кирпичи, панели и т.д.), 
      или те показатели, которые определены его шаблоном, планом проектирования. К внешнему состоянию 
      может относиться положение дома на географической карте, то есть его координаты, цвет дома, 
      и так далее, то есть такие показатели, которые для каждого отдельного дома могут быть 
      относительно индивидуальны.

    * В этом случае реализация строительства домов на C# с применением паттерна Flyweight могла 
      бы выглядеть следующим образом:
*/

using Flyweight.Classes;

class Program
{
    static void Main(string[] args)
    {
        double longitude = 37.61;
        double latitude = 55.74;

        HouseFactory houseFactory = new HouseFactory();
        for (int i = 0; i < 5; i++)
        {
            House panelHouse = houseFactory.GetHouse("Panel");
            if (panelHouse != null)
                panelHouse.Build(longitude, latitude);
            longitude += 0.1;
            latitude += 0.1;
        }

        for (int i = 0; i < 5; i++)
        {
            House brickHouse = houseFactory.GetHouse("Brick");
            if (brickHouse != null)
                brickHouse.Build(longitude, latitude);
            longitude += 0.1;
            latitude += 0.1;
        }

        Console.Read();
    }
}